<html>
<head>
<link rel="stylesheet" href="/blog/tufte.css" />
<script
src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'
async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  // skipTags: ["<pre>", "<code>"]
  tex2jax: {
      skipTags: ["script","noscript","style","textarea"]
      }
  });
</script>
<title>TITLE</title>
</head>
<body>
    <p><a href=/blog/>To index</a></p>

    <article>
<h1>TITLE</h1><section>
<ul>
<li>learning from experience</li>
<li>driver first, using monte carlo methods</li>
<li>tic tac toe</li>
<li>driver</li>
<li>when there are too many states: give some examples, including mastermind</li>
</ul>
<p>-- nice intro--</p>
<p>Let's get up to speed with an example: racetrack driving<label class="sidenote-number"></label><span class="sidenote">taken from Sutton and
Barto, <em>reinforcement learning</em>, Chapter X, etc</span>. We'll take the famous Formula 1
racing driver Pimi Roverlainen and transplant him onto a racetrack in gridworld.</p>
<p>INSERT IMAGE</p>
<p>Pimi's task is to learn how to drive from any given point on the red starting line to any
point of his choice on the green ending line. He should do this as quickly as
possible. We'll model Pimi's driving in a simplified way: namely as a sequence
of moves from square to square<label class="sidenote-number"></label><span class="sidenote">a <em>Markov Decision Process</em> by our earlier
terminology</span>. After each move he gets to accelerate by +1, 0 or -1 velocity units
in either or both of the X and Y directions, giving a total of 9
possibilities<label class="sidenote-number"></label><span class="sidenote">(+1,+1), (+1, 0), (+1, -1), etc.</span>. His new velocity then
determines in which square he'll end up next. For safety, let's cap both the
X-speed and Y-speed at 5 units.</p>
<p>On such an easy course, this is an easy task for Pimi. So, to make things harder,
we'll blindfold him so he cannot see where he's going. All he has access to is
9 <em>success logbooks</em> at each square in the racetrack -- so <code>\(9N\)</code> logbooks,
where <code>\(N\)</code> is the number of squares in the track. Each logbook belongs to 1 of
the 9 possible accelerations Pimi could make, say for example <code>\((+1, 0)\)</code>. Then
this logbook <code>\((+1, 0)\)</code> has a
full record of the number of moves it's taken Pimi to
arrive at the green line in the past starting at the current square, given
that the action taken was <code>\((+1, 0)\)</code>.</p>
<p>As Pimi drives with his blindfold on, he drives at random by accelerating in
random directions because he can't see where he's going. He often crashes and
when this happens, he takes a sip of refreshing blueberry juice, fetches a
plaster or two and then starts again from a random point on the red starting line,
keeping a stiff upper lip. As he does so, he crosses more and more squares, the
smoke rises, the racetrack gets worn and the <code>\(9N\)</code> logbooks fill up.
That's a lot of paper!</p>
<p>Once there's a fair amount of records in each of the <code>\(9N\)</code> logbooks, Pimi can
start using them to make decisions instead of driving and crashing randomly.
Each success logbook is indeed a measure of success of its corresponding action at that
square in gridworld: the logbook averaging the <em>lowest</em> number of moves
to completion should intuitively correspond to the best action. In fact, this
is the case, and the approach just outlined is an example of a class of
algorithms called <em>Monte-Carlo algorithms</em> in reinforcement learning.</p>
</section></article>

    <p><a href=/blog/>To index</a></p>

    <div class="dates">
        First published 28 September 2018 at 14:53 UTC, <br />
        last updated 28 September 2018 at 15:08 UTC.
    </div>
</body>
</html>
